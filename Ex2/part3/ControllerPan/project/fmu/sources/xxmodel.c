/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  src\xxmodel.c
 *  model: JIWY-co-sim
 *  expmt: JIWY-co-sim
 *  date:  May 31, 2019
 *  time:  7:02:36 PM
 *  user:  Universiteit Twente
 *  from:  20-sim 4.7 Campus License
 *  build: 4.7.0.8692
 **********************************************************/

/* This file contains the actual model variables and equations */

/* Note: Alias variables are the result of full optimization
   of the model in 20-sim. As a result, only the real variables
   are used in the model for speed. The user may also include
   the alias variables by adding them to the end of the array:

   XXDouble xx_variables[NUMBER_VARIABLES + NUMBER_ALIAS_VARIABLES + 1];
   XXString xx_variable_names[] = {
     VARIABLE_NAMES, ALIAS_VARIABLE_NAMES, NULL
   };

   and calculate them directly after the output equations:

   void XXCalculateOutput (void)
   {
     OUTPUT_EQUATIONS
     ALIAS_EQUATIONS
   }
*/

/* system include files */
#include <stdlib.h>
#include <math.h>

/* 20-sim include files */
#include "xxmodel.h"
#include "xxfuncs.h"


#if (7 > 8192) && defined _MSC_VER
#pragma optimize("", off)
#endif
/* this method is called before calculation is possible */
void XXModelInitialize (xx_ModelInstance* model_instance)
{
	/* set the parameters */
	xx_P[0] = 10.0;		/* ControllerPan\PID_Pan\kp {} */
	xx_P[1] = 5.0;		/* ControllerPan\PID_Pan\tauD {s} */
	xx_P[2] = 0.1;		/* ControllerPan\PID_Pan\beta {} */
	xx_P[3] = 1000.0;		/* ControllerPan\PID_Pan\tauI {s} */
	xx_P[4] = 0.003141592;		/* MA_Pan\Conversion\K */
	xx_P[5] = 1.0;		/* MA_Pan\Limit\maximum */
	xx_P[6] = -1.0;		/* MA_Pan\Limit\minimum */


	/* set the initial values */
	xx_I[0] = 0.0;		/* ControllerPan\PID_Pan\uD_previous_initial */
	xx_I[1] = 0.0;		/* ControllerPan\PID_Pan\error_previous_initial */
	xx_I[2] = 0.0;		/* ControllerPan\PID_Pan\uI_previous_initial */


	/* set the states */
	xx_s[0] = xx_I[0];		/* ControllerPan\PID_Pan\uD_previous */
	xx_s[1] = xx_I[1];		/* ControllerPan\PID_Pan\error_previous */
	xx_s[2] = xx_I[2];		/* ControllerPan\PID_Pan\uI_previous */


}
#if (7 > 8192) && defined _MSC_VER
#pragma optimize("", on)
#endif

/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void XXCalculateInitial (xx_ModelInstance* model_instance)
{


	/* set the states */
	xx_s[0] = xx_I[0];		/* ControllerPan\PID_Pan\uD_previous */
	xx_s[1] = xx_I[1];		/* ControllerPan\PID_Pan\error_previous */
	xx_s[2] = xx_I[2];		/* ControllerPan\PID_Pan\uI_previous */


}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void XXCalculateStatic (xx_ModelInstance* model_instance)
{

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void XXCalculateInput (xx_ModelInstance* model_instance)
{

}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void XXCalculateDynamic (xx_ModelInstance* model_instance)
{
	/* ControllerPan\PID_Pan\factor = 1 / (sampletime + ControllerPan\PID_Pan\tauD * ControllerPan\PID_Pan\beta); */
	xx_V[1] = 1.0 / (xx_step_size + xx_P[1] * xx_P[2]);

	/* MA_Pan\measIO = measIO; */
	xx_V[5] = xx_V[7];

	/* ControllerPan\SetPointPan = SetPointPan; */
	xx_V[2] = xx_V[8];

	/* MA_Pan\Conversion\output = MA_Pan\Conversion\K * MA_Pan\measIO; */
	xx_V[3] = xx_P[4] * xx_V[5];

	/* ControllerPan\PID_Pan\error = ControllerPan\SetPointPan - MA_Pan\Conversion\output; */
	xx_R[1] = xx_V[2] - xx_V[3];

	/* ControllerPan\PID_Pan\uD = ControllerPan\PID_Pan\factor * (((ControllerPan\PID_Pan\tauD * ControllerPan\PID_Pan\uD_previous) * ControllerPan\PID_Pan\beta + (ControllerPan\PID_Pan\tauD * ControllerPan\PID_Pan\kp) * (ControllerPan\PID_Pan\error - ControllerPan\PID_Pan\error_previous)) + (sampletime * ControllerPan\PID_Pan\kp) * ControllerPan\PID_Pan\error); */
	xx_R[0] = xx_V[1] * (((xx_P[1] * xx_s[0]) * xx_P[2] + (xx_P[1] * xx_P[0]) * (xx_R[1] - xx_s[1])) + (xx_step_size * xx_P[0]) * xx_R[1]);

	/* ControllerPan\PID_Pan\uI = ControllerPan\PID_Pan\uI_previous + (sampletime * ControllerPan\PID_Pan\uD) / ControllerPan\PID_Pan\tauI; */
	xx_R[2] = xx_s[2] + (xx_step_size * xx_R[0]) / xx_P[3];

	/* ControllerPan\PID_Pan\output = ControllerPan\PID_Pan\uI + ControllerPan\PID_Pan\uD; */
	xx_V[0] = xx_R[2] + xx_R[0];

	/* MA_Pan\Limit\output = (if ControllerPan\PID_Pan\output < MA_Pan\Limit\minimum then MA_Pan\Limit\minimum else (if ControllerPan\PID_Pan\output > MA_Pan\Limit\maximum then MA_Pan\Limit\maximum else ControllerPan\PID_Pan\output end) end); */
	xx_V[4] = ((xx_V[0] < xx_P[6]) ? 
		/* MA_Pan\Limit\minimum */
		xx_P[6]
	:
		/* (if ControllerPan\PID_Pan\output > MA_Pan\Limit\maximum then MA_Pan\Limit\maximum else ControllerPan\PID_Pan\output end) */
		((xx_V[0] > xx_P[5]) ? 
			/* MA_Pan\Limit\maximum */
			xx_P[5]
		:
			/* ControllerPan\PID_Pan\output */
			xx_V[0]
		)
	);


	/* increment the step counter */
	model_instance->steps++;
}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void XXCalculateOutput (xx_ModelInstance* model_instance)
{
	/* steerIO = MA_Pan\Limit\output; */
	xx_V[6] = xx_V[4];

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void XXCalculateFinal (xx_ModelInstance* model_instance)
{

}

/* this method is called after all calculations are performed */
void XXModelTerminate(xx_ModelInstance* model_instance)
{
}

