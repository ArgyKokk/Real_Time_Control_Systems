/**
 * Source file for the FMI_JoyStick model
 * Generated by the TERRA CSPm2LUNA generator version 1.1.3
 *
 * FMI C++ glue code to connect to JoyStick
 * Modifying this file is absolutely not recommended!
 *
 * protected region document description on begin
 *
 * protected region document description end
 */

#include "FMI_JoyStick.h"
// protected region additional headers on begin
// Each additional header should get a corresponding dependency in the Makefile
// protected region additional headers end
#include "timer/GlobalTime.h"
namespace JoyStick { namespace FMI_JoyStick { 

FMI_JoyStick::FMI_JoyStick(double &JoyStickPan, double &JoyStickTilt) :
    CodeBlock(), JoyStickPan(JoyStickPan), JoyStickTilt(JoyStickTilt){
  SETNAME(this, "FMI_JoyStick");

// Create the text for the header of the measurement log
std::string measurementNames = "Time,JoyStickPan,JoyStickTilt";
  
// Initialization of the log functions
logger->initLogger("measurement_JoyStick.csv","log.txt",measurementNames);

// Load shared lib
handle = dlopen("/usr/local/lib/libSOJoyStick.so",RTLD_LAZY);

// Instantiation of the FMU
f_instantiate = (fp_instantiate)dlsym(handle,"fmi2Instantiate");
s1 = f_instantiate("JoyStick", fmi2CoSimulation,"{60e2b061-6309-416d-a849-b430948dc8ae}", "", &cbf, fmi2True, fmi2False);
if(s1 == NULL)
{
   logger->fmiLog(NULL, "JoyStick", fmi2Error, "error", "fmi2Instatiate is not created.");
}  
else
{
   logger->fmiLog(NULL, "JoyStick", fmi2OK, "info","fmi2Instatiate is created correctly.");
}

// Set variables for simulation
timeStep = 0.01;
currentTime = 0.0;
status = fmi2OK;
simulationFinished = false;

f_setup = (fp_setup)dlsym(handle,"fmi2SetupExperiment");
f_setup(s1,fmi2False, 0.0, 0.0, fmi2True, 20.0);

fmi2EnterInitializationMode(s1);

fmi2ValueReference parameterRealRef[6] = {0,1,2,3,4,5};
fmi2Real parameterRealVal[6] = {1.0,5.0,1.0,2.0,6.0,-1.0};
fmi2SetReal(s1,parameterRealRef,6,parameterRealVal);
  
  

fmi2ValueReference outputRealRef[2] = {10,11};
fmi2Real outputRealVal[2] = {0,0};
fmi2GetReal(s1,outputRealRef,2,outputRealVal);
JoyStickPan = outputRealVal[0]; JoyStickTilt = outputRealVal[1]; 
  
  

f_exit = (fp_exit)dlsym(handle,"fmi2ExitInitializationMode"); 
f_exit(s1);

g_time = currentTime;
g_stepsize = timeStep;
}

FMI_JoyStick::~FMI_JoyStick()
{
fmi2Terminate(s1);
fmi2FreeInstance(s1);
}

void FMI_JoyStick::execute()
{

if(simulationFinished == false && status == fmi2OK)
{
  
  
  
  
  // Save the values of the input and output to a file
  logger->saveMeasurementPoint(std::to_string(currentTime) + "," + std::to_string(JoyStickPan) + "," + std::to_string(JoyStickTilt));
  
  if(g_time < 20.0)
  {  
  	f_doStep = (fp_doStep)dlsym(handle,"fmi2DoStep");
    if(f_doStep(s1,g_time,g_stepsize,fmi2True) != fmi2OK)
    {
      printf("FMI: Error no simulation\n");
    }
    //currentTime = currentTime + timeStep;
  
    fmi2ValueReference outputRealRef[2] = {10,11};
    fmi2Real outputRealVal[2] = {0,0};
    fmi2GetReal(s1,outputRealRef,2,outputRealVal);
    JoyStickPan = outputRealVal[0]; JoyStickTilt = outputRealVal[1]; 
  
  
  }
  else
  {
    simulationFinished = true;
  }
}
else if(status != fmi2OK)
{
  printf("FMU: The simulation is stopped because of an error\n");
  std::_Exit(0);
}
else
{
  printf("FMU: Simulation is done\n");
  std::_Exit(0);
}
}

// protected region additional functions on begin
// protected region additional functions end

// Close namespace(s)
} } 
