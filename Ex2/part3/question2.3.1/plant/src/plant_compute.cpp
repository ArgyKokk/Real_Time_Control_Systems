/**
 * Source file for the plant_compute model
 * Generated by the TERRA CSPm2LUNA generator version 1.1.3
 *
 * protected region document description on begin
 *
 * protected region document description end
 */

#include "plant_compute.h"
// protected region additional headers on begin
// Each additional header should get a corresponding dependency in the Makefile
// protected region additional headers end
#include "timer/GlobalTime.h"
#include <zmq.h>

#include <fstream>
#include <sstream>
#include <string>
#include <vector>

namespace plant { namespace plant_compute { 

std::ofstream outputStream;
const unsigned int bufferSize = 1024;

plant_compute::plant_compute(double &controlPan, double &controlTilt, double &pan, double &tilt) :
    CodeBlock(), controlPan(controlPan), controlTilt(controlTilt), pan(pan), tilt(tilt){
  SETNAME(this, "plant_compute");

  // protected region constructor on begin
  //Init zmq socket
    context = zmq_ctx_new ();
    zmqsocket = zmq_socket (context, ZMQ_REQ);

    int result = zmq_bind(zmqsocket, "tcp://*:5555"); //server
    if(result == -1)
    {
  	  //If see this error, use command: lsof -i :5555, to get the PID, then use command: kill -9 PID
  	  printf("[ZMQ] Error: cannot bind\n");
  	  std::_Exit(0);
    }

    //Open log
    outputStream.open("cosim.log");
  // protected region constructor end
}

plant_compute::~plant_compute()
{
  // protected region destructor on begin
	zmq_close (zmqsocket);
	  zmq_ctx_destroy (context);
  // protected region destructor end
}

void plant_compute::execute()
{
  // protected region execute code on begin
	static double ct_time = 0.0;

		//Buffer to receive and send data
		static double recv[bufferSize], send[bufferSize];

		//Simple case to continue data exchange
		while(g_time + g_stepsize > ct_time)
		{
			// Receive message, place it into a cpp string.
			char buffer[bufferSize];
			int size = zmq_recv(zmqsocket, buffer, bufferSize - 1, 0);

			if (size == -1) {
				outputStream << "[ZMQ] Error: Receive timeout" << std::endl;
			}

			if (size > bufferSize - 1){
				size = bufferSize - 1;
			}
			buffer[size] = 0;
			std::string msg(buffer);
			outputStream << "[ZMQ] Received " << msg << "\n";

			if (msg.compare("STOP") == 0) {
				outputStream << "[ZMQ] Received STOP" << std::endl;
			}

			// Loop string, extract comma separated (double) values.
			std::vector<double> vect;
			std::stringstream ss_in(msg);
			double j;
			while (ss_in >> j)
			{
				vect.push_back(j);

				if (ss_in.peek() == ',' || ss_in.peek() == ' ') {
					ss_in.ignore();
				}
			}

			// Place extracted values into the output array
			for (unsigned int k = 0; k < vect.size(); k++) {
				//printf("vect.size() is %d\n", vect.size());
				if (k <= vect.size()-1) {
					recv[k] = vect.at(k);
				}
			}

			//need to receive height and ct_time
			tilt= recv[0];
			pan = recv[1];
			ct_time = recv[2];

			//need to send control
			send[0] = controlTilt;
			send[1] = controlPan;

			/*
			* Handle outgoing
			*/
			// Place all input values of this block into a string. Comma separated.

			//Set send_size
			int send_size = 2;

			std::stringstream ss;
			for (int i = 0; i < send_size; i++)
			{
				ss << send[i];

				if (i + 1 != send_size) {
					ss << ",";
				}
			}

			// Convert c++ string to a char array
			std::string reply_str = ss.str();
			char tab2[1024];
			strncpy(tab2, reply_str.c_str(), sizeof(tab2));
			tab2[sizeof(tab2) - 1] = 0;

			// Send it
			outputStream << "[ZMQ] Outgoing: " << reply_str << std::endl;
			zmq_send(zmqsocket, tab2, sizeof(tab2) - 1, 0);

			//Force to exit correctly when co-sim is finished when reaching 20.000 sec
			if(g_time + g_stepsize > 20.000)
			{
				zmq_close (zmqsocket);
				zmq_ctx_destroy (context);
				std::_Exit(0);
			}
		}

		//Advance g_time (also aka DE time)
		g_time = g_time + g_stepsize;
  // protected region execute code end
}

// protected region additional functions on begin
// protected region additional functions end

// Close namespace(s)
} } 
