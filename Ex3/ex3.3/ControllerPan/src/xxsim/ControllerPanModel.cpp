/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  src\xxsim\ControllerPanModel.cpp
 *  subm:  ControllerPanModel
 *  model: JIWY-better-tuned-v2
 *  expmt: JIWY-better-tuned-v2
 *  date:  June 15, 2019
 *  time:  4:43:29 PM
 *  user:  Universiteit Twente
 *  from:  20-sim 4.7 Campus License
 *  build: 4.7.0.8692
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>

/* 20-sim include files */
#include "xxsim/ControllerPanModel.hpp"

using namespace std;

namespace ControllerPan
{

  ControllerPanModel::ControllerPanModel()
  {
    setupComputation();
  }

  ControllerPanModel::~ControllerPanModel(void)
  {
    /* delete IO mappings */
    while(!m_inputs.empty())
    {
      IAdapter20Sim* a = m_inputs.back();
      m_inputs.pop_back();
      delete a;
    }

    while(!m_outputs.empty())
    {
      IAdapter20Sim* a = m_outputs.back();
      m_outputs.pop_back();
      delete a;
    }

    /* free memory */
    delete[] C;
    delete[] P;
    delete[] I;
    delete[] V;
    delete[] s;
    delete[] R;
    delete[] M;
    delete[] U;
    delete[] workarray;
  }

  void ControllerPanModel::setupComputation()
  {
    start_time = 0.0;
    finish_time = 0;
    step_size = 0.005;
    time = 0;
    major = true;

    number_constants = 0;
    number_parameters = 7;
    number_initialvalues = 3;
    number_variables = 9;
    number_states = 3;
    number_rates = 3;
    number_matrices = 0;
    number_unnamed = 0;

    /* the variable arrays */
    C = new XXDouble[0 + 1]; /* constants */
    P = new XXDouble[7 + 1]; /* parameters, currently only one type of parameter exists: double */
    I = new XXDouble[3 + 1]; /* initial values */
    V = new XXDouble[9 + 1]; /* variables */

    s = new XXDouble[3 + 1]; /* states */
    R = new XXDouble[3 + 1]; /* rates (or new states) */
    M = new XXMatrix[0 + 1]; /* matrices */
    U = new XXDouble[0 + 1]; /* unnamed */
    workarray = new XXDouble[0 + 1];
  }

  bool ControllerPanModel::initializeComputation()
  {
    myintegmethod.Initialize(this);

    /* initialization phase (allocating memory) */
    initialize = true;
    //CONSTANTS
    

    //PARAMETERS
    	P[0] = 0.5;		/* ControllerPan\PID_Pan\kp {} */
	P[1] = 10.0;		/* ControllerPan\PID_Pan\tauD {s} */
	P[2] = 0.1;		/* ControllerPan\PID_Pan\beta {} */
	P[3] = 5.0;		/* ControllerPan\PID_Pan\tauI {s} */
	P[4] = 0.003141592;		/* MA_Pan\Conversion\K */
	P[5] = 1.0;		/* MA_Pan\Limit\maximum */
	P[6] = -1.0;		/* MA_Pan\Limit\minimum */


    //INITIAL VALUES
    	I[0] = 0.0;		/* ControllerPan\PID_Pan\uD_previous_initial */
	I[1] = 0.0;		/* ControllerPan\PID_Pan\error_previous_initial */
	I[2] = 0.0;		/* ControllerPan\PID_Pan\uI_previous_initial */


    //MATRICES
    

    //INITIALIZE_DEPSTATES
    //INITIALIZE_ALGLOOPS
    //INITIALIZE_CONSTRAINTS%

    //INPUTS
    //INITIALIZE_INPUTS% -> not the actual inputs

    //OUTPUTS
    //INITIALIZE_OUTPUTS% -> not the actual outputs

    //INITIALIZE_FAVORITE_PARS
    //INITIALIZE_FAVORITE_VARS

    //INITIALIZE_CONSTANTS%
    /* set the states */
    //INITIALIZE_STATES%

    /* set the matrices */
    //INITIALIZE_MATRICES%

    //STATES - do NOT move this line up!
    	s[0] = I[0];		/* ControllerPan\PID_Pan\uD_previous */
	s[1] = I[1];		/* ControllerPan\PID_Pan\error_previous */
	s[2] = I[2];		/* ControllerPan\PID_Pan\uI_previous */


    /* end of initialization phase */
    initialize = false;
    return initialize;
  }

  void ControllerPanModel::CopyInputsToVariables()
  {
    for(unsigned int i = 0; i < m_inputs.size(); ++i)
    {
      m_inputs[i]->copyVariableToXXVariable();
    }
  }

  void ControllerPanModel::CopyVariablesToOutputs()
  {
    for(unsigned int i = 0; i < m_outputs.size(); ++i)
    {
      m_outputs[i]->copyXXVariableToVariable();
    }
  }

  void ControllerPanModel::start()
  {
    initializeComputation();

    /* calculate initial and static equations */
    CalculateInitial ();
    CalculateStatic ();
    CopyInputsToVariables ();
    CalculateInput ();
    CalculateDynamic();
    CalculateOutput ();
    CopyVariablesToOutputs ();
  }

  void ControllerPanModel::step()
  {
    /* another precessor submodel could determine the parameters of this submodel
     and therefore the static parameter calculations need to be performed. */
    CalculateStatic ();

    /* main calculation of the model */
    CopyInputsToVariables (); //get input from port
    CalculateInput ();
    myintegmethod.Step();
    CalculateOutput ();
    CopyVariablesToOutputs (); //send output to port
  }

  void ControllerPanModel::stop()
  {
    CopyInputsToVariables();
    /* calculate the final model equations */
    CalculateFinal ();
    CopyVariablesToOutputs();
  }

  /* This function calculates the initial equations of the model.
   * These equations are calculated before anything else
   */
  inline void ControllerPanModel::CalculateInitial (void)
  {
    
  }

  /* This function calculates the static equations of the model.
   * These equations are only dependent from parameters and constants
   */
  inline void ControllerPanModel::CalculateStatic (void)
  {
    
  }

  /* This function calculates the input equations of the model.
   * These equations are dynamic equations that must not change
   * in calls from the integration method (like random and delay).
   */
  inline void ControllerPanModel::CalculateInput (void)
  {
    
  }

  /* This function calculates the dynamic equations of the model.
   * These equations are called from the integration method
   * to calculate the new model rates (that are then integrated).
   */
  inline void ControllerPanModel::CalculateDynamic (void)
  {
    	/* ControllerPan\PID_Pan\factor = 1 / (sampletime + ControllerPan\PID_Pan\tauD * ControllerPan\PID_Pan\beta); */
	V[1] = 1.0 / (step_size + P[1] * P[2]);

	/* MA_Pan\measIO = measIO; */
	V[5] = V[7];

	/* ControllerPan\SetPointPan = SetPointPan; */
	V[2] = V[8];

	/* MA_Pan\Conversion\output = MA_Pan\Conversion\K * MA_Pan\measIO; */
	V[3] = P[4] * V[5];

	/* ControllerPan\PID_Pan\error = ControllerPan\SetPointPan - MA_Pan\Conversion\output; */
	R[1] = V[2] - V[3];

	/* ControllerPan\PID_Pan\uD = ControllerPan\PID_Pan\factor * (((ControllerPan\PID_Pan\tauD * ControllerPan\PID_Pan\uD_previous) * ControllerPan\PID_Pan\beta + (ControllerPan\PID_Pan\tauD * ControllerPan\PID_Pan\kp) * (ControllerPan\PID_Pan\error - ControllerPan\PID_Pan\error_previous)) + (sampletime * ControllerPan\PID_Pan\kp) * ControllerPan\PID_Pan\error); */
	R[0] = V[1] * (((P[1] * s[0]) * P[2] + (P[1] * P[0]) * (R[1] - s[1])) + (step_size * P[0]) * R[1]);

	/* ControllerPan\PID_Pan\uI = ControllerPan\PID_Pan\uI_previous + (sampletime * ControllerPan\PID_Pan\uD) / ControllerPan\PID_Pan\tauI; */
	R[2] = s[2] + (step_size * R[0]) / P[3];

	/* ControllerPan\PID_Pan\output = ControllerPan\PID_Pan\uI + ControllerPan\PID_Pan\uD; */
	V[0] = R[2] + R[0];

	/* MA_Pan\Limit\output = (if ControllerPan\PID_Pan\output < MA_Pan\Limit\minimum then MA_Pan\Limit\minimum else (if ControllerPan\PID_Pan\output > MA_Pan\Limit\maximum then MA_Pan\Limit\maximum else ControllerPan\PID_Pan\output end) end); */
	V[4] = ((V[0] < P[6]) ? 
		/* MA_Pan\Limit\minimum */
		P[6]
	:
		/* (if ControllerPan\PID_Pan\output > MA_Pan\Limit\maximum then MA_Pan\Limit\maximum else ControllerPan\PID_Pan\output end) */
		((V[0] > P[5]) ? 
			/* MA_Pan\Limit\maximum */
			P[5]
		:
			/* ControllerPan\PID_Pan\output */
			V[0]
		)
	);

  }

  /* This function calculates the output equations of the model.
   * These equations are not needed for calculation of the rates
   * and are kept separate to make the dynamic set of equations smaller.
   * These dynamic equations are called often more than one time for each
   * integration step that is taken. This makes model computation much faster.
   */
  inline void ControllerPanModel::CalculateOutput (void)
  {
    	/* steerIO = MA_Pan\Limit\output; */
	V[6] = V[4];

      }

  /* This function calculates the final equations of the model.
   * These equations are calculated after all the calculations
   * are performed
   */
  inline void ControllerPanModel::CalculateFinal (void)
  {
    
  }

}

